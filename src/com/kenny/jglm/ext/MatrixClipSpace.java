package com.kenny.jglm.ext;

import com.kenny.jglm.Trigonometric;
import com.kenny.jglm.detail.Matrix4d;
import com.kenny.jglm.detail.Matrix4f;
import com.kenny.jglm.detail.Setup;

/**
 * Defines functions that generate clip space transformation matrices. <br><br>
 * 
 * The matrices generated by this extension use standard OpenGL fixed-function<br>
 * conventions. For example, the lookAt function generates a transform from world<br>
 * space into the specific eye space that the projective matrix functions<br>
 * (perspective, ortho, etc) are designed to expect. The OpenGL compatibility<br>
 * specifications defines the particular layout of this eye space.
 * 
 * @defgroup ext_matrix_clip_space GLM_EXT_matrix_clip_space
 * @see ext_matrix_transform
 * @see ext_matrix_projection
 * 
 * @author Kenny
 */
public class MatrixClipSpace {
	
	/**
	 * Creates a matrix for projecting two-dimensional coordinates onto the screen.
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * 
	 * @see <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluOrtho2D.xml">gluOrtho2D man page</a>
	 */
	public static final Matrix4f ortho(float left, float right, float bottom, float top) {
		Matrix4f Result = new Matrix4f(1f);
		Result.set(0, 0, (2) / (right - left));
		Result.set(1, 1, (2) / (top - bottom));
		Result.set(2, 2, - (1));
		Result.set(3, 0, - (right + left) / (right - left));
		Result.set(3, 1, - (top + bottom) / (top - bottom));
		return Result;
	}
	
	/**
	 * Creates a matrix for projecting two-dimensional coordinates onto the screen.
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * 
	 * @see <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluOrtho2D.xml">gluOrtho2D man page</a>
	 */
	public static final Matrix4d ortho(double left, double right, double bottom, double top) {
		Matrix4d Result = new Matrix4d(1d);
		Result.set(0, 0, (2) / (right - left));
		Result.set(1, 1, (2) / (top - bottom));
		Result.set(2, 2, - (1));
		Result.set(3, 0, - (right + left) / (right - left));
		Result.set(3, 1, - (top + bottom) / (top - bottom));
		return Result;
	}
	
	/**
     * Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates. <br>
     * <br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1<br>
	 * respectively. (Direct3D clip volume definition).
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane. 
	 */
	public static final Matrix4f orthoLH_ZO(float left, float right, float bottom, float top, float zNear, float zFar) {
		Matrix4f Result = new Matrix4f(1);
		Result.set(0, 0, (2) / (right - left));
		Result.set(1, 1, (2) / (top - bottom));
		Result.set(2, 2, (1) / (zFar - zNear));
		Result.set(3, 0, - (right + left) / (right - left));
		Result.set(3, 1, - (top + bottom) / (top - bottom));
		Result.set(3, 2, - zNear / (zFar - zNear));
		return Result;
	}
	
	/**
     * Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates. <br>
     * <br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1<br>
	 * respectively. (Direct3D clip volume definition).
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane. 
	 */
	public static final Matrix4d orthoLH_ZO(double left, double right, double bottom, double top, double zNear, double zFar) {
		Matrix4d Result = new Matrix4d(1);
		Result.set(0, 0, (2) / (right - left));
		Result.set(1, 1, (2) / (top - bottom));
		Result.set(2, 2, (1) / (zFar - zNear));
		Result.set(3, 0, - (right + left) / (right - left));
		Result.set(3, 1, - (top + bottom) / (top - bottom));
		Result.set(3, 2, - zNear / (zFar - zNear));
		return Result;
	}
	
	/**
     * Creates a matrix for an orthographic parallel viewing volume, using right-handed coordinates. <br>
     * <br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1<br>
	 * respectively. (OpenGL clip volume definition).
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane. 
	 */
	public static final Matrix4f orthoLH_NO(float left, float right, float bottom, float top, float zNear, float zFar) {
		Matrix4f Result = new Matrix4f(1);
		Result.set(0, 0, (2) / (right - left));
		Result.set(1, 1, (2) / (top - bottom));
		Result.set(2, 2, (2) / (zFar - zNear));
		Result.set(3, 0, - (right + left) / (right - left));
		Result.set(3, 1, - (top + bottom) / (top - bottom));
		Result.set(3, 2, - (zFar + zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
     * Creates a matrix for an orthographic parallel viewing volume, using right-handed coordinates. <br>
     * <br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1<br>
	 * respectively. (OpenGL clip volume definition).
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane. 
	 */
	public static final Matrix4d orthoLH_NO(double left, double right, double bottom, double top, double zNear, double zFar) {
		Matrix4d Result = new Matrix4d(1);
		Result.set( 0, 0, (2) / (right - left));
		Result.set( 1, 1, (2) / (top - bottom));
		Result.set( 2, 2, (2) / (zFar - zNear));
		Result.set( 3, 0, - (right + left) / (right - left));
		Result.set( 3, 1, - (top + bottom) / (top - bottom));
		Result.set( 3, 2, - (zFar + zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
     * Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates. <br>
     * <br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1<br>
	 * respectively. (DirectX clip volume definition).
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
     * @param zNear Near clip plane. 
	 * @param zFar Far clip plane. 
	 */
	public static final Matrix4f orthoRH_ZO(float left, float right, float bottom, float top, float zNear, float zFar) {
		Matrix4f Result = new Matrix4f(1);
		Result.set(0, 0, (2) / (right - left));
		Result.set(1, 1, (2) / (top - bottom));
		Result.set(2, 2, - (1) / (zFar - zNear));
		Result.set(3, 0, - (right + left) / (right - left));
		Result.set(3, 1, - (top + bottom) / (top - bottom));
		Result.set(3, 2, - zNear / (zFar - zNear));
		return Result;
	}
	
	/**
     * Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates. <br>
     * <br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1<br>
	 * respectively. (DirectX clip volume definition).
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane. 
	 */
	public static final Matrix4d orthoRH_ZO(double left, double right, double bottom, double top, double zNear, double zFar) {
		Matrix4d Result = new Matrix4d(1);
		Result.set(0, 0, (2) / (right - left));
		Result.set(1, 1, (2) / (top - bottom));
		Result.set(2, 2, - (1) / (zFar - zNear));
		Result.set(3, 0, - (right + left) / (right - left));
		Result.set(3, 1, - (top + bottom) / (top - bottom));
		Result.set(3, 2, - zNear / (zFar - zNear));
		return Result;
	}
	
	/**
     * Creates a matrix for an orthographic parallel viewing volume, using right-handed coordinates. <br>
     * <br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1<br>
	 * respectively. (OpenGL clip volume definition).
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane. 
	 */
	public static final Matrix4f orthoRH_NO(float left, float right, float bottom, float top, float zNear, float zFar) {
		Matrix4f Result = new Matrix4f(1);
		Result.set(0, 0, (2) / (right - left));
		Result.set(1, 1, (2) / (top - bottom));
		Result.set(2, 2, - (2) / (zFar - zNear));
		Result.set(3, 0, - (right + left) / (right - left));
		Result.set(3, 1, - (top + bottom) / (top - bottom));
		Result.set(3, 2, - (zFar + zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
     * Creates a matrix for an orthographic parallel viewing volume, using right-handed coordinates. <br>
     * <br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1<br>
	 * respectively. (OpenGL clip volume definition).
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane. 
	 */
	public static final Matrix4d orthoRH_NO(double left, double right, double bottom, double top, double zNear, double zFar) {
		Matrix4d Result = new Matrix4d(1);
		Result.set(0, 0, (2) / (right - left));
		Result.set(1, 1, (2) / (top - bottom));
		Result.set(2, 2, - (2) / (zFar - zNear));
		Result.set(3, 0, - (right + left) / (right - left));
		Result.set(3, 1, - (top + bottom) / (top - bottom));
		Result.set(3, 2, - (zFar + zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
     * Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates. <br>
     * <br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1<br>
	 * respectively. (DirectX clip volume definition).
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane. 
	 */
	public static final Matrix4f orthoZO(float left, float right, float bottom, float top, float zNear, float zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return orthoLH_ZO(left, right, bottom, top, zNear, zFar);
		else
			return orthoRH_ZO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
     * Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates. <br>
     * <br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1<br>
	 * respectively. (DirectX clip volume definition).
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane. 
	 */
	public static final Matrix4d orthoZO(double left, double right, double bottom, double top, double zNear, double zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return orthoLH_ZO(left, right, bottom, top, zNear, zFar);
		else
			return orthoRH_ZO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
	 * Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates <br>
	 * if {@link Setup#GLM_FORCE_LEFT_HANDED} is used or right-handed coordinates otherwise. <br> <br>
	 * 
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1  <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane. 
	 */
	public static final Matrix4f orthoNO(float left, float right, float bottom, float top, float zNear, float zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return orthoLH_NO(left, right, bottom, top, zNear, zFar);
		else
			return orthoRH_NO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
	 * Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates <br>
	 * if {@link Setup#GLM_FORCE_LEFT_HANDED} is used or right-handed coordinates otherwise. <br> <br>
	 * 
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1  <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane. 
	 */
	public static final Matrix4d orthoNO(double left, double right, double bottom, double top, double zNear, double zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return orthoLH_NO(left, right, bottom, top, zNear, zFar);
		else
			return orthoRH_NO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
	 * Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates. <br>
	 *  <br>
	 * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is used, the near and far clip planes correspond to z <br>
	 * normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition) <br>
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates of <br>
	 * -1 and +1 respectively. (OpenGL clip volume definition)
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane. 
	 */
	public static final Matrix4f orthoLH(float left, float right, float bottom, float top, float zNear, float zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return orthoLH_ZO(left, right, bottom, top, zNear, zFar);
		else
			return orthoLH_NO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
	 * Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates. <br>
	 *  <br>
	 * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is used, the near and far clip planes correspond to z <br>
	 * normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition) <br>
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates of <br>
	 * -1 and +1 respectively. (OpenGL clip volume definition)
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane. 
	 */
	public static final Matrix4d orthoLH(double left, double right, double bottom, double top, double zNear, double zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return orthoLH_ZO(left, right, bottom, top, zNear, zFar);
		else
			return orthoLH_NO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
	 * Creates a matrix for an orthographic parallel viewing volume, using right-handed coordinates. <br>
	 * <br>
	 * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is used, the near and far clip planes correspond to z normalized<br>
	 * device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)<br>
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane.
	 */
	public static final Matrix4f orthoRH(float left, float right, float bottom, float top, float zNear, float zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return orthoRH_ZO(left, right, bottom, top, zNear, zFar);
		else
			return orthoRH_NO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
	 * Creates a matrix for an orthographic parallel viewing volume, using right-handed coordinates. <br>
	 * <br>
	 * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is used, the near and far clip planes correspond to z normalized<br>
	 * device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)<br>
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane.
	 */
	public static final Matrix4d orthoRH(double left, double right, double bottom, double top, double zNear, double zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return orthoRH_ZO(left, right, bottom, top, zNear, zFar);
		else
			return orthoRH_NO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
	 * Creates a matrix for an orthographic parallel viewing volume, using the default handedness <br>
	 * and default near and far clip planes definition. <br>
	 * To change default handedness use {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE}. To change default  <br>
	 * near and far clip planes definition use {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE}.
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane.
	 */
	public static final Matrix4f ortho(float left, float right, float bottom, float top, float zNear, float zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE) {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return orthoLH_ZO(left, right, bottom, top, zNear, zFar);
			} else {
				return orthoRH_ZO(left, right, bottom, top, zNear, zFar);
			}
		}
		else {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return orthoLH_NO(left, right, bottom, top, zNear, zFar);
			} else {
				return orthoRH_NO(left, right, bottom, top, zNear, zFar);
			}
		}
	}
	
	/**
	 * Creates a matrix for an orthographic parallel viewing volume, using the default handedness <br>
	 * and default near and far clip planes definition. <br>
	 * To change default handedness use {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE}. To change default  <br>
	 * near and far clip planes definition use {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE}.
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zNear Near clip plane. 
	 * @param zFar Far clip plane.
	 */
	public static final Matrix4d ortho(double left, double right, double bottom, double top, double zNear, double zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE) {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return orthoLH_ZO(left, right, bottom, top, zNear, zFar);
			} else {
				return orthoRH_ZO(left, right, bottom, top, zNear, zFar);
			}
		}
		else {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return orthoLH_NO(left, right, bottom, top, zNear, zFar);
			} else {
				return orthoRH_NO(left, right, bottom, top, zNear, zFar);
			}
		}
	}
	
	/**
	 * Creates a left handed frustum matrix. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1 <br> 
	 * respectively. (Direct3D clip volume definition). <br>
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param farVal Near clip plane. 
	 * @param nearVal Far clip plane.
	 */
	public static final Matrix4f frustumLH_ZO(float left, float right, float bottom, float top, float nearVal, float farVal) {
		Matrix4f Result = new Matrix4f(0);
		Result.set(0, 0, ((2) * nearVal) / (right - left));
		Result.set(1, 1, ((2) * nearVal) / (top - bottom));
		Result.set(2, 0, (right + left) / (right - left));
		Result.set(2, 1, (top + bottom) / (top - bottom));
		Result.set(2, 2, farVal / (farVal - nearVal));
		Result.set(2, 3, (1));
		Result.set(3, 2, -(farVal * nearVal) / (farVal - nearVal));
		return Result;
	}
	
	/**
	 * Creates a left handed frustum matrix. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1 <br> 
	 * respectively. (Direct3D clip volume definition). <br>
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param farVal Near clip plane. 
	 * @param nearVal Far clip plane.
	 */
	public static final Matrix4d frustumLH_ZO(double left, double right, double bottom, double top, double nearVal, double farVal) {
		Matrix4d Result = new Matrix4d(0);
		Result.set(0, 0, ((2) * nearVal) / (right - left));
		Result.set(1, 1, ((2) * nearVal) / (top - bottom));
		Result.set(2, 0, (right + left) / (right - left));
		Result.set(2, 1, (top + bottom) / (top - bottom));
		Result.set(2, 2, farVal / (farVal - nearVal));
		Result.set(2, 3, (1));
		Result.set(3, 2, -(farVal * nearVal) / (farVal - nearVal));
		return Result;
	}
	
	/**
	 * Creates a left handed frustum matrix. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1 <br> 
	 * respectively. (OpenGL clip volume definition). <br>
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param farVal Near clip plane. 
	 * @param nearVal Far clip plane.
	 */
	public static final Matrix4f frustumLH_NO(float left, float right, float bottom, float top, float nearVal, float farVal) {
		Matrix4f Result = new Matrix4f(0);
		Result.set(0, 0, ((2) * nearVal) / (right - left));
		Result.set(1, 1, ((2) * nearVal) / (top - bottom));
		Result.set(2, 0, (right + left) / (right - left));
		Result.set(2, 1, (top + bottom) / (top - bottom));
		Result.set(2, 2, (farVal + nearVal) / (farVal - nearVal));
		Result.set(2, 3, (1));
		Result.set(3, 2, -(2 * farVal * nearVal) / (farVal - nearVal));
		return Result;
	}
	
	/**
	 * Creates a left handed frustum matrix. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1 <br> 
	 * respectively. (OpenGL clip volume definition). <br>
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param farVal Near clip plane. 
	 * @param nearVal Far clip plane.
	 */
	public static final Matrix4d frustumLH_NO(double left, double right, double bottom, double top, double nearVal, double farVal) {
		Matrix4d Result = new Matrix4d(0);
		Result.set(0, 0, ((2) * nearVal) / (right - left));
		Result.set(1, 1, ((2) * nearVal) / (top - bottom));
		Result.set(2, 0, (right + left) / (right - left));
		Result.set(2, 1, (top + bottom) / (top - bottom));
		Result.set(2, 2, (farVal + nearVal) / (farVal - nearVal));
		Result.set(2, 3, (1));
		Result.set(3, 2, -(2 * farVal * nearVal) / (farVal - nearVal));
		return Result;
	}
	
	/**
	 * Creates a right handed frustum matrix. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1 <br> 
	 * respectively. (Direct3D clip volume definition). <br>
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param farVal Near clip plane. 
	 * @param nearVal Far clip plane.
	 */
	public static final Matrix4f frustumRH_ZO(float left, float right, float bottom, float top, float nearVal, float farVal) {
		Matrix4f Result = new Matrix4f(0);
		Result.set(0, 0, ((2) * nearVal) / (right - left));
		Result.set(1, 1, ((2) * nearVal) / (top - bottom));
		Result.set(2, 0, (right + left) / (right - left));
		Result.set(2, 1, (top + bottom) / (top - bottom));
		Result.set(2, 2, farVal / (nearVal - farVal));
		Result.set(2, 3, (-1));
		Result.set(3, 2, -(farVal * nearVal) / (farVal - nearVal));
		return Result;
	}
	
	/**
	 * Creates a right handed frustum matrix. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1 <br> 
	 * respectively. (Direct3D clip volume definition). <br>
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param farVal Near clip plane. 
	 * @param nearVal Far clip plane.
	 */
	public static final Matrix4d frustumRH_ZO(double left, double right, double bottom, double top, double nearVal, double farVal) {
		Matrix4d Result = new Matrix4d(0);
		Result.set(0, 0, ((2) * nearVal) / (right - left));
		Result.set(1, 1, ((2) * nearVal) / (top - bottom));
		Result.set(2, 0, (right + left) / (right - left));
		Result.set(2, 1, (top + bottom) / (top - bottom));
		Result.set(2, 2, farVal / (nearVal - farVal));
		Result.set(2, 3, (-1));
		Result.set(3, 2, -(farVal * nearVal) / (farVal - nearVal));
		return Result;
	}
	
	/**
	 * Creates a right handed frustum matrix. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1 <br> 
	 * respectively. (OpenGL clip volume definition). <br>
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param farVal Near clip plane. 
	 * @param nearVal Far clip plane.
	 */
	public static final Matrix4f frustumRH_NO(float left, float right, float bottom, float top, float nearVal, float farVal) {
		Matrix4f Result = new Matrix4f(0);
		Result.set(0, 0, ((2) * nearVal) / (right - left));
		Result.set(1, 1, ((2) * nearVal) / (top - bottom));
		Result.set(2, 0, (right + left) / (right - left));
		Result.set(2, 1, (top + bottom) / (top - bottom));
		Result.set(2, 2, - (farVal + nearVal) / (farVal - nearVal));
		Result.set(2, 3, (-1));
		Result.set(3, 2, - ((2) * farVal * nearVal) / (farVal - nearVal));
		return Result;
	}
	
	/**
	 * Creates a right handed frustum matrix. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1 <br> 
	 * respectively. (OpenGL clip volume definition). <br>
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param farVal Near clip plane. 
	 * @param nearVal Far clip plane.
	 */
	public static final Matrix4d frustumRH_NO(double left, double right, double bottom, double top, double nearVal, double farVal) {
		Matrix4d Result = new Matrix4d(0);
		Result.set(0, 0, ((2) * nearVal) / (right - left));
		Result.set(1, 1, ((2) * nearVal) / (top - bottom));
		Result.set(2, 0, (right + left) / (right - left));
		Result.set(2, 1, (top + bottom) / (top - bottom));
		Result.set(2, 2, - (farVal + nearVal) / (farVal - nearVal));
		Result.set(2, 3, (-1));
		Result.set(3, 2, - ((2) * farVal * nearVal) / (farVal - nearVal));
		return Result;
	}
	
	/**
	 * Creates a frustum matrix using left-handed coordinates if {@link Setup#GLM_FORCE_LEFT_HANDED} <br>
	 * if defined or right-handed coordinates otherwise.<br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1 <br>
	 * respectively. (Direct3D clip volume definition)
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zFar Near clip plane. 
	 * @param zNear Far clip plane.
	 */
	public static final Matrix4f frustumZO(float left, float right, float bottom, float top, float zNear, float zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return frustumLH_ZO(left, right, bottom, top, zNear, zFar);
		else
			return frustumRH_ZO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
	 * Creates a frustum matrix using left-handed coordinates if {@link Setup#GLM_FORCE_LEFT_HANDED} <br>
	 * if defined or right-handed coordinates otherwise.<br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1 <br>
	 * respectively. (Direct3D clip volume definition)
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zFar Near clip plane. 
	 * @param zNear Far clip plane.
	 */
	public static final Matrix4d frustumZO(double left, double right, double bottom, double top, double zNear, double zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return frustumLH_ZO(left, right, bottom, top, zNear, zFar);
		else
			return frustumRH_ZO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
	 * Creates a frustum matrix using left-handed coordinates if {@link Setup#GLM_FORCE_LEFT_HANDED} <br>
	 * if defined or right-handed coordinates otherwise.<br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1 <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zFar Near clip plane. 
	 * @param zNear Far clip plane.
	 */
	public static final Matrix4f frustumNO(float left, float right, float bottom, float top, float zNear, float zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return frustumLH_NO(left, right, bottom, top, zNear, zFar);
		else
			return frustumRH_NO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
	 * Creates a frustum matrix using left-handed coordinates if {@link Setup#GLM_FORCE_LEFT_HANDED} <br>
	 * if defined or right-handed coordinates otherwise.<br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1 <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zFar Near clip plane. 
	 * @param zNear Far clip plane.
	 */
	public static final Matrix4d frustumNO(double left, double right, double bottom, double top, double zNear, double zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return frustumLH_NO(left, right, bottom, top, zNear, zFar);
		else
			return frustumRH_NO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
	 * Creates a left-handed frustum matrix. <br>
	 * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is defined, the near and far clip planes correspond <br>
	 * to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition) <br>
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1  <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zFar Near clip plane. 
	 * @param zNear Far clip plane.
	 */
	public static final Matrix4f frustumLH(float left, float right, float bottom, float top, float zNear, float zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return frustumLH_ZO(left, right, bottom, top, zNear, zFar);
		else
			return frustumLH_NO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
	 * Creates a left-handed frustum matrix. <br>
	 * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is defined, the near and far clip planes correspond <br>
	 * to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition) <br>
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1  <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zFar Near clip plane. 
	 * @param zNear Far clip plane.
	 */
	public static final Matrix4d frustumLH(double left, double right, double bottom, double top, double zNear, double zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return frustumLH_ZO(left, right, bottom, top, zNear, zFar);
		else
			return frustumLH_NO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
	 * Creates a right-handed frustum matrix. <br>
	 * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is defined, the near and far clip planes correspond <br>
	 * to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition) <br>
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1  <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zFar Near clip plane. 
	 * @param zNear Far clip plane.
	 */
	public static final Matrix4f frustumRH(float left, float right, float bottom, float top, float zNear, float zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return frustumRH_ZO(left, right, bottom, top, zNear, zFar);
		else
			return frustumRH_NO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
	 * Creates a right-handed frustum matrix. <br>
	 * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is defined, the near and far clip planes correspond <br>
	 * to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition) <br>
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1  <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zFar Near clip plane. 
	 * @param zNear Far clip plane.
	 */
	public static final Matrix4d frustumRH(double left, double right, double bottom, double top, double zNear, double zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return frustumRH_ZO(left, right, bottom, top, zNear, zFar);
		else
			return frustumRH_NO(left, right, bottom, top, zNear, zFar);
	}
	
	/**
	 * Creates a frustum matrix with default handedness, using the default handedness and default <br>
	 * near and far clip planes definition. To change default handedness use  <br> 
	 * {@link Setup#GLM_FORCE_LEFT_HANDED}. To change default near and far clip planes definition  <br>
	 * use {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE}.
	 * 
	 * @see <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml">glFrustum man page</a>
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zFar Near clip plane. 
	 * @param zNear Far clip plane.
	 */
	public static final Matrix4f frustum(float left, float right, float bottom, float top, float zNear, float zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE) {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return frustumLH_ZO(left, right, bottom, top, zNear, zFar);
			} else {
				return frustumRH_ZO(left, right, bottom, top, zNear, zFar);
			}
		}
		else {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return frustumLH_NO(left, right, bottom, top, zNear, zFar);
			} else {
				return frustumRH_NO(left, right, bottom, top, zNear, zFar);
			}
		}
	}
	
	/**
	 * Creates a frustum matrix with default handedness, using the default handedness and default <br>
	 * near and far clip planes definition. To change default handedness use  <br> 
	 * {@link Setup#GLM_FORCE_LEFT_HANDED}. To change default near and far clip planes definition  <br>
	 * use {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE}.
	 * 
	 * @see <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml">glFrustum man page</a>
	 * 
	 * @param left A left border of ortho box.
	 * @param right A right border of ortho box.
	 * @param bottom A bottom border of ortho box.
	 * @param top A top border of ortho box.
	 * @param zFar Near clip plane. 
	 * @param zNear Far clip plane.
	 */
	public static final Matrix4d frustum(double left, double right, double bottom, double top, double zNear, double zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE) {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return frustumLH_ZO(left, right, bottom, top, zNear, zFar);
			} else {
				return frustumRH_ZO(left, right, bottom, top, zNear, zFar);
			}
		}
		else {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return frustumLH_NO(left, right, bottom, top, zNear, zFar);
			} else {
				return frustumRH_NO(left, right, bottom, top, zNear, zFar);
			}
		}
	}
	
	/**
	 * Creates a matrix for a right handed, symetric perspective-view frustum. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1  <br>
	 * respectively. (Direct3D clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveRH_ZO(float fovy, float aspect, float zNear, float zFar) {
		//assert(abs(aspect - std::numeric_limits<T>::epsilon()) > (0));

		float tanHalfFovy = Trigonometric.tan(fovy / (2));

		Matrix4f Result = new Matrix4f(0);
		Result.set(0, 0, (1) / (aspect * tanHalfFovy));
		Result.set(1, 1, (1) / (tanHalfFovy));
		Result.set(2, 2, zFar / (zNear - zFar));
		Result.set(2, 3, - (1));
		Result.set(3, 2, -(zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
	 * Creates a matrix for a right handed, symetric perspective-view frustum. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1  <br>
	 * respectively. (Direct3D clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveRH_ZO(double fovy, double aspect, double zNear, double zFar) {
		//assert(abs(aspect - std::numeric_limits<T>::epsilon()) > (0));

		double tanHalfFovy = Trigonometric.tan(fovy / (2));

		Matrix4d Result = new Matrix4d(0);
		Result.set(0, 0, (1) / (aspect * tanHalfFovy));
		Result.set(1, 1, (1) / (tanHalfFovy));
		Result.set(2, 2, zFar / (zNear - zFar));
		Result.set(2, 3, - (1));
		Result.set(3, 2, -(zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
	 * Creates a matrix for a right handed, symetric perspective-view frustum. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1  <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveRH_NO(float fovy, float aspect, float zNear, float zFar) {
		float tanHalfFovy = Trigonometric.tan(fovy / (2));

		Matrix4f Result = new Matrix4f(0);
		Result.set(0, 0, (1) / (aspect * tanHalfFovy));
		Result.set(1, 1, (1) / (tanHalfFovy));
		Result.set(2, 2, - (zFar + zNear) / (zFar - zNear));
		Result.set(2, 3, - (1));
		Result.set(3, 2, - ((2) * zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
	 * Creates a matrix for a right handed, symetric perspective-view frustum. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1  <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveRH_NO(double fovy, double aspect, double zNear, double zFar) {
		double tanHalfFovy = Trigonometric.tan(fovy / (2));

		Matrix4d Result = new Matrix4d(0);
		Result.set(0, 0, (1) / (aspect * tanHalfFovy));
		Result.set(1, 1, (1) / (tanHalfFovy));
		Result.set(2, 2, - (zFar + zNear) / (zFar - zNear));
		Result.set(2, 3, - (1));
		Result.set(3, 2, - ((2) * zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
	 * Creates a matrix for a left handed, symetric perspective-view frustum. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1  <br>
	 * respectively. (DirectX clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveLH_ZO(float fovy, float aspect, float zNear, float zFar) {
		float tanHalfFovy = Trigonometric.tan(fovy / (2));
		
		Matrix4f Result = new Matrix4f(0);
		Result.set(0, 0, (1) / (aspect * tanHalfFovy));
		Result.set(1, 1, (1) / (tanHalfFovy));
		Result.set(2, 2, zFar / (zFar - zNear));
		Result.set(2, 3, (1));
		Result.set(3, 2, -(zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
	 * Creates a matrix for a left handed, symetric perspective-view frustum. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1  <br>
	 * respectively. (DirectX clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveLH_ZO(double fovy, double aspect, double zNear, double zFar) {
		double tanHalfFovy = Trigonometric.tan(fovy / (2));
		
		Matrix4d Result = new Matrix4d(0);
		Result.set(0, 0, (1) / (aspect * tanHalfFovy));
		Result.set(1, 1, (1) / (tanHalfFovy));
		Result.set(2, 2, zFar / (zFar - zNear));
		Result.set(2, 3, (1));
		Result.set(3, 2, -(zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
	 * Creates a matrix for a left handed, symetric perspective-view frustum. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1  <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveLH_NO(float fovy, float aspect, float zNear, float zFar) {
		float tanHalfFovy = Trigonometric.tan(fovy / (2));
		
		Matrix4f Result = new Matrix4f(0);
		Result.set(0, 0, (1) / (aspect * tanHalfFovy));
		Result.set(1, 1, (1) / (tanHalfFovy));
		Result.set(2, 2, (zFar + zNear) / (zFar - zNear));
		Result.set(2, 3, (1));
		Result.set(3, 2, - ((2) * zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
	 * Creates a matrix for a left handed, symetric perspective-view frustum. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1  <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveLH_NO(double fovy, double aspect, double zNear, double zFar) {
		double tanHalfFovy = Trigonometric.tan(fovy / (2));
		
		Matrix4d Result = new Matrix4d(0);
		Result.set(0, 0, (1) / (aspect * tanHalfFovy));
		Result.set(1, 1, (1) / (tanHalfFovy));
		Result.set(2, 2, (zFar + zNear) / (zFar - zNear));
		Result.set(2, 3, (1));
		Result.set(3, 2, - ((2) * zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
	 * Creates a matrix for a symetric perspective-view frustum using left-handed coordinates if
	 * {@link Setup#GLM_FORCE_LEFT_HANDED} if using or right-handed coordinates otherwise.
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1 
	 * respectively. (Direct3D clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveZO(float fovy, float aspect, float zNear, float zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return perspectiveLH_ZO(fovy, aspect, zNear, zFar);
		else
			return perspectiveRH_ZO(fovy, aspect, zNear, zFar);
	}
	
	/**
	 * Creates a matrix for a symetric perspective-view frustum using left-handed coordinates if
	 * {@link Setup#GLM_FORCE_LEFT_HANDED} if using or right-handed coordinates otherwise.
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1 
	 * respectively. (Direct3D clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveZO(double fovy, double aspect, double zNear, double zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return perspectiveLH_ZO(fovy, aspect, zNear, zFar);
		else
			return perspectiveRH_ZO(fovy, aspect, zNear, zFar);
	}
	
	/**
	 * Creates a matrix for a symetric perspective-view frustum using left-handed coordinates if
	 * {@link Setup#GLM_FORCE_LEFT_HANDED} if using or right-handed coordinates otherwise.
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1 
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveNO(float fovy, float aspect, float zNear, float zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return perspectiveLH_NO(fovy, aspect, zNear, zFar);
		else
			return perspectiveRH_NO(fovy, aspect, zNear, zFar);
	}
	
	/**
	 * Creates a matrix for a symetric perspective-view frustum using left-handed coordinates if
	 * {@link Setup#GLM_FORCE_LEFT_HANDED} if using or right-handed coordinates otherwise.
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1 
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveNO(double fovy, double aspect, double zNear, double zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return perspectiveLH_NO(fovy, aspect, zNear, zFar);
		else
			return perspectiveRH_NO(fovy, aspect, zNear, zFar);
	}
	
	/**
	 * Creates a matrix for a left handed, symetric perspective-view frustum. <br>
	 * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is true, the near and far clip planes <br>
	 * correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)<br>
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates<br>
	 *  of -1 and +1 respectively. (OpenGL clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveLH(float fovy, float aspect, float zNear, float zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return perspectiveLH_ZO(fovy, aspect, zNear, zFar);
		else
			return perspectiveLH_NO(fovy, aspect, zNear, zFar);
	}
	
	/**
	 * Creates a matrix for a left handed, symetric perspective-view frustum. <br>
	 * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is true, the near and far clip planes <br>
	 * correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)<br>
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates<br>
	 *  of -1 and +1 respectively. (OpenGL clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveLH(double fovy, double aspect, double zNear, double zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return perspectiveLH_ZO(fovy, aspect, zNear, zFar);
		else
			return perspectiveLH_NO(fovy, aspect, zNear, zFar);
	}
	
	/**
	 * Creates a matrix for a right handed, symetric perspective-view frustum. <br>
	 * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is true, the near and far clip planes <br>
	 * correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)<br>
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates<br>
	 *  of -1 and +1 respectively. (OpenGL clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveRH(float fovy, float aspect, float zNear, float zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return perspectiveRH_ZO(fovy, aspect, zNear, zFar);
		else
			return perspectiveRH_NO(fovy, aspect, zNear, zFar);
	}
	
	/**
	 * Creates a matrix for a right handed, symetric perspective-view frustum. <br>
	 * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is true, the near and far clip planes <br>
	 * correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)<br>
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates<br>
	 *  of -1 and +1 respectively. (OpenGL clip volume definition)
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveRH(double fovy, double aspect, double zNear, double zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return perspectiveRH_ZO(fovy, aspect, zNear, zFar);
		else
			return perspectiveRH_NO(fovy, aspect, zNear, zFar);
	}
	
	/**
	 * Creates a matrix for a symetric perspective-view frustum based on the default handedness <br>
	 * and default near and far clip planes definition. <br>
	 * To change default handedness use {@link Setup#GLM_FORCE_LEFT_HANDED}. To change default  <br>
	 * near and far clip planes definition use {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE}.
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspective(float fovy, float aspect, float zNear, float zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE) {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return perspectiveLH_ZO(fovy, aspect, zNear, zFar);
			} else {
				return perspectiveRH_ZO(fovy, aspect, zNear, zFar);
			}
		}
		else {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return perspectiveLH_NO(fovy, aspect, zNear, zFar);
			} else {
				return perspectiveRH_NO(fovy, aspect, zNear, zFar);
			}
		}
	}
	
	/**
	 * Creates a matrix for a symetric perspective-view frustum based on the default handedness <br>
	 * and default near and far clip planes definition. <br>
	 * To change default handedness use {@link Setup#GLM_FORCE_LEFT_HANDED}. To change default  <br>
	 * near and far clip planes definition use {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE}.
	 * 
	 * @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspective(double fovy, double aspect, double zNear, double zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE) {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return perspectiveLH_ZO(fovy, aspect, zNear, zFar);
			} else {
				return perspectiveRH_ZO(fovy, aspect, zNear, zFar);
			}
		}
		else {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return perspectiveLH_NO(fovy, aspect, zNear, zFar);
			} else {
				return perspectiveRH_NO(fovy, aspect, zNear, zFar);
			}
		}
	}
	
    // perspectiveFov

	/**
	 * Builds a perspective projection matrix based on a field of view using right-handed coordinates. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of <br>
	 * 0 and +1 respectively. (Direct3D clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveFovRH_ZO(float fov, float width, float height, float zNear, float zFar) {
		//assert(width > (0));
		//assert(height > (0));
		//assert(fov > (0));

		float rad = fov;
		float h = Trigonometric.cos((0.5f) * rad) / Trigonometric.sin((0.5f) * rad);
		float w = h * height / width; ///todo max(width , Height) / min(width , Height)?

		Matrix4f Result = new Matrix4f(0);
		Result.set(0, 0, w);
		Result.set(1, 1, h);
		Result.set(2, 2, zFar / (zNear - zFar));
		Result.set(2, 3, - (1));
		Result.set(3, 2, -(zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
	 * Builds a perspective projection matrix based on a field of view using right-handed coordinates. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of <br>
	 * 0 and +1 respectively. (Direct3D clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveFovRH_ZO(double fov, double width, double height, double zNear, double zFar) {
		//assert(width > (0));
		//assert(height > (0));
		//assert(fov > (0));

		double rad = fov;
		double h = Trigonometric.cos((0.5D) * rad) / Trigonometric.sin((0.5D) * rad);
		double w = h * height / width; ///todo max(width , Height) / min(width , Height)?

		Matrix4d Result = new Matrix4d(0);
		Result.set(0, 0, w);
		Result.set(1, 1, h);
		Result.set(2, 2, zFar / (zNear - zFar));
		Result.set(2, 3, - (1));
		Result.set(3, 2, -(zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
	 * Builds a perspective projection matrix based on a field of view using right-handed coordinates. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of <br>
	 * -1 and +1 respectively. (OpenGL clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveFovRH_NO(float fov, float width, float height, float zNear, float zFar) {
		//assert(width > (0));
		//assert(height > (0));
		//assert(fov > (0));

		final float rad = fov;
		final float h = Trigonometric.cos((0.5f) * rad) / Trigonometric.sin((0.5f) * rad);
		final float w = h * height / width; ///todo max(width , Height) / min(width , Height)?

		Matrix4f Result = new Matrix4f((0));
		Result.set(0, 0, w);
		Result.set(1, 1, h);
		Result.set(2, 2, - (zFar + zNear) / (zFar - zNear));
		Result.set(2, 3, - (1));
		Result.set(3, 2, - ((2) * zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
	 * Builds a perspective projection matrix based on a field of view using right-handed coordinates. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of <br>
	 * -1 and +1 respectively. (OpenGL clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveFovRH_NO(double fov, double width, double height, double zNear, double zFar) {
		//assert(width > (0));
		//assert(height > (0));
		//assert(fov > (0));

		final double rad = fov;
		final double h = Trigonometric.cos((0.5d) * rad) / Trigonometric.sin((0.5d) * rad);
		final double w = h * height / width; ///todo max(width , Height) / min(width , Height)?

		Matrix4d Result = new Matrix4d((0));
		Result.set(0, 0, w);
		Result.set(1, 1, h);
		Result.set(2, 2, - (zFar + zNear) / (zFar - zNear));
		Result.set(2, 3, - (1));
		Result.set(3, 2, - ((2) * zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
	 * Builds a perspective projection matrix based on a field of view using left-handed coordinates. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of <br>
	 * 0 and +1 respectively. (DirectX clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveFovLH_ZO(float fov, float width, float height, float zNear, float zFar) {
		//		assert(width > (0));
		//assert(height > (0));
		//assert(fov > (0));

		final float rad = fov;
		final float h = Trigonometric.cos((0.5f) * rad) / Trigonometric.sin((0.5f) * rad);
		final float w = h * height / width; ///todo max(width , Height) / min(width , Height)?

		Matrix4f Result = new Matrix4f((0));
		Result.set(0, 0, w);
		Result.set(1, 1, h);
		Result.set(2, 2, zFar / (zFar - zNear));
		Result.set(2, 3, (1));
		Result.set(3, 2, -(zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
	 * Builds a perspective projection matrix based on a field of view using left-handed coordinates. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of <br>
	 * 0 and +1 respectively. (DirectX clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveFovLH_ZO(double fov, double width, double height, double zNear, double zFar) {
		//		assert(width > (0));
		//assert(height > (0));
		//assert(fov > (0));

		final double rad = fov;
		final double h = Trigonometric.cos((0.5d) * rad) / Trigonometric.sin((0.5d) * rad);
		final double w = h * height / width; ///todo max(width , Height) / min(width , Height)?

		Matrix4d Result = new Matrix4d((0));
		Result.set(0, 0, w);
		Result.set(1, 1, h);
		Result.set(2, 2, zFar / (zFar - zNear));
		Result.set(2, 3, (1));
		Result.set(3, 2, -(zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
	 * Builds a perspective projection matrix based on a field of view using left-handed coordinates. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of <br>
	 * -1 and +1 respectively. (OpenGL clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveFovLH_NO(float fov, float width, float height, float zNear, float zFar) {
		//assert(width > (0));
		//assert(height > (0));
		//assert(fov > (0));

		final float rad = fov;
		final float h = Trigonometric.cos((0.5f) * rad) / Trigonometric.sin((0.5f) * rad);
		final float w = h * height / width; ///todo max(width , Height) / min(width , Height)?

		Matrix4f Result = new Matrix4f((0));
		Result.set(0, 0, w);
		Result.set(1, 1, h);
		Result.set(2, 2, (zFar + zNear) / (zFar - zNear));
		Result.set(2, 3, (1));
		Result.set(3, 2, - ((2) * zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**
	 * Builds a perspective projection matrix based on a field of view using left-handed coordinates. <br>
	 * The near and far clip planes correspond to z normalized device coordinates of <br>
	 * -1 and +1 respectively. (OpenGL clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveFovLH_NO(double fov, double width, double height, double zNear, double zFar) {
		//assert(width > (0));
		//assert(height > (0));
		//assert(fov > (0));

		final double rad = fov;
		final double h = Trigonometric.cos((0.5) * rad) / Trigonometric.sin((0.5) * rad);
		final double w = h * height / width; ///todo max(width , Height) / min(width , Height)?

		Matrix4d Result = new Matrix4d((0));
		Result.set(0, 0, w);
		Result.set(1, 1, h);
		Result.set(2, 2, (zFar + zNear) / (zFar - zNear));
		Result.set(2, 3, (1));
		Result.set(3, 2, - ((2) * zFar * zNear) / (zFar - zNear));
		return Result;
	}
	
	/**  
     * Builds a perspective projection matrix based on a field of view using left-handed coordinates if <br>
     * {@link Setup#GLM_FORCE_LEFT_HANDED} if defined or right-handed coordinates otherwise.<br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1 <br>
	 * respectively. (Direct3D clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveFovZO(float fov, float width, float height, float zNear, float zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return perspectiveFovLH_ZO(fov, width, height, zNear, zFar);
		else
			return perspectiveFovRH_ZO(fov, width, height, zNear, zFar);
	}
	
	/**  
     * Builds a perspective projection matrix based on a field of view using left-handed coordinates if <br>
     * {@link Setup#GLM_FORCE_LEFT_HANDED} if defined or right-handed coordinates otherwise.<br>
	 * The near and far clip planes correspond to z normalized device coordinates of 0 and +1 <br>
	 * respectively. (Direct3D clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveFovZO(double fov, double width, double height, double zNear, double zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return perspectiveFovLH_ZO(fov, width, height, zNear, zFar);
		else
			return perspectiveFovRH_ZO(fov, width, height, zNear, zFar);
	}
	
	/**  
     * Builds a perspective projection matrix based on a field of view using left-handed coordinates if <br>
     * {@link Setup#GLM_FORCE_LEFT_HANDED} if defined or right-handed coordinates otherwise.<br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1 <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveFovNO(float fov, float width, float height, float zNear, float zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return perspectiveFovLH_NO(fov, width, height, zNear, zFar);
		else
			return perspectiveFovRH_NO(fov, width, height, zNear, zFar);
	}
	
	/**  
     * Builds a perspective projection matrix based on a field of view using left-handed coordinates if <br>
     * {@link Setup#GLM_FORCE_LEFT_HANDED} if defined or right-handed coordinates otherwise.<br>
	 * The near and far clip planes correspond to z normalized device coordinates of -1 and +1 <br>
	 * respectively. (OpenGL clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveFovNO(double fov, double width, double height, double zNear, double zFar) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return perspectiveFovLH_NO(fov, width, height, zNear, zFar);
		else
			return perspectiveFovRH_NO(fov, width, height, zNear, zFar);
	}
	
	/**  
     * Builds a perspective projection matrix based on a field of view using left-handed coordinates.
     * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is defined, the near and far clip planes correspond to z normalized device
     * coordinates of 0 and +1 respectively. (Direct3D clip volume definition)
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates of 
	 * -1 and +1 respectively. (OpenGL clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveFovLH(float fov, float width, float height, float zNear, float zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return perspectiveFovLH_ZO(fov, width, height, zNear, zFar);
		else
			return perspectiveFovLH_NO(fov, width, height, zNear, zFar);
	}
	
	/**  
     * Builds a perspective projection matrix based on a field of view using left-handed coordinates.
     * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is defined, the near and far clip planes correspond to z normalized device
     * coordinates of 0 and +1 respectively. (Direct3D clip volume definition)
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates of 
	 * -1 and +1 respectively. (OpenGL clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveFovLH(double fov, double width, double height, double zNear, double zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return perspectiveFovLH_ZO(fov, width, height, zNear, zFar);
		else
			return perspectiveFovLH_NO(fov, width, height, zNear, zFar);
	}
	
	/**  
     * Builds a perspective projection matrix based on a field of view using right-handed coordinates.
     * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is defined, the near and far clip planes correspond to z normalized device
     * coordinates of 0 and +1 respectively. (Direct3D clip volume definition)
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates of 
	 * -1 and +1 respectively. (OpenGL clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveFovRH(float fov, float width, float height, float zNear, float zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return perspectiveFovRH_ZO(fov, width, height, zNear, zFar);
		else
			return perspectiveFovRH_NO(fov, width, height, zNear, zFar);
	}
	
	/**  
     * Builds a perspective projection matrix based on a field of view using right-handed coordinates.
     * If {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE} is defined, the near and far clip planes correspond to z normalized device
     * coordinates of 0 and +1 respectively. (Direct3D clip volume definition)
	 * Otherwise, the near and far clip planes correspond to z normalized device coordinates of 
	 * -1 and +1 respectively. (OpenGL clip volume definition)
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveFovRH(double fov, double width, double height, double zNear, double zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE)
			return perspectiveFovRH_ZO(fov, width, height, zNear, zFar);
		else
			return perspectiveFovRH_NO(fov, width, height, zNear, zFar);
	}
	
	/**
	 * Builds a perspective projection matrix based on a field of view and the default handedness and <br>
	 * default near and far clip planes definition. <br>
	 * To change default handedness use {@value Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE}. To change default near and far clip <br>
	 * planes definition use {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE}.
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4f perspectiveFov(float fov, float width, float height, float zNear, float zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE) {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return perspectiveFovLH_ZO(fov, width, height, zNear, zFar);
			} else {
				return perspectiveFovRH_ZO(fov, width, height, zNear, zFar);
			}
		}
		else {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return perspectiveFovLH_NO(fov, width, height, zNear, zFar);
			} else {
				return perspectiveFovRH_NO(fov, width, height, zNear, zFar);
			}
		}
	}
	
	/**
	 * Builds a perspective projection matrix based on a field of view and the default handedness and <br>
	 * default near and far clip planes definition. <br>
	 * To change default handedness use {@value Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE}. To change default near and far clip <br>
	 * planes definition use {@link Setup#GLM_FORCE_DEPTH_ZERO_TO_ONE}.
	 * 
	 * @param fov Expressed in radians.
	 * @param width Width of the viewport
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param zFar Specifies the distance from the viewer to the far clipping plane (always positive).
	 */
	public static final Matrix4d perspectiveFov(double fov, double width, double height, double zNear, double zFar) {
		if(Setup.GLM_FORCE_DEPTH_ZERO_TO_ONE) {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return perspectiveFovLH_ZO(fov, width, height, zNear, zFar);
			} else {
				return perspectiveFovRH_ZO(fov, width, height, zNear, zFar);
			}
		}
		else {
			if(Setup.GLM_FORCE_LEFT_HANDED) {
				return perspectiveFovLH_NO(fov, width, height, zNear, zFar);
			} else {
				return perspectiveFovRH_NO(fov, width, height, zNear, zFar);
			}
		}
	}
	
	// infinityPerspective
	
	/**
	 * Creates a matrix for a right handed, symmetric perspective-view frustum with far plane at 
	 * infinite.
	 * 
	 * @param fovy  Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 */
	public static final Matrix4f infinitePerspectiveRH(float fovy, float aspect, float zNear) {
		float range = Trigonometric.tan(fovy / (2)) * zNear;
		float left = -range * aspect;
		float right = range * aspect;
		float bottom = -range;
		float top = range;

		Matrix4f Result = new Matrix4f((0));
		Result.set(0, 0, ((2) * zNear) / (right - left));
		Result.set(1, 1, ((2) * zNear) / (top - bottom));
		Result.set(2, 2, - (1));
		Result.set(2, 3, - (1));
		Result.set(3, 2, - (2) * zNear);
		return Result;
	}
	
	/**
	 * Creates a matrix for a right handed, symmetric perspective-view frustum with far plane at 
	 * infinite.
	 * 
	 * @param fovy  Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 */
	public static final Matrix4d infinitePerspectiveRH(double fovy, double aspect, double zNear) {
		double range = Trigonometric.tan(fovy / (2)) * zNear;
		double left = -range * aspect;
		double right = range * aspect;
		double bottom = -range;
		double top = range;

		Matrix4d Result = new Matrix4d((0));
		Result.set(0, 0, ((2) * zNear) / (right - left));
		Result.set(1, 1, ((2) * zNear) / (top - bottom));
		Result.set(2, 2, - (1));
		Result.set(2, 3, - (1));
		Result.set(3, 2, - (2) * zNear);
		return Result;
	}
	
	/**
	 * Creates a matrix for a left handed, symmetric perspective-view frustum with far plane at 
	 * infinite.
	 * 
	 * @param fovy  Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 */
	public static final Matrix4f infinitePerspectiveLH(float fovy, float aspect, float zNear) {
		final float range = Trigonometric.tan(fovy / (2)) * zNear;
		final float left = -range * aspect;
		final float right = range * aspect;
		final float bottom = -range;
		final float top = range;

		Matrix4f Result = new Matrix4f(0);
		Result.set(0, 0, ((2) * zNear) / (right - left));
		Result.set(1, 1, ((2) * zNear) / (top - bottom));
		Result.set(2, 2, (1));
		Result.set(2, 3, (1));
		Result.set(3, 2, -(2) * zNear);
		return Result;
	}
	
	/**
	 * Creates a matrix for a left handed, symmetric perspective-view frustum with far plane at 
	 * infinite.
	 * 
	 * @param fovy  Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param height Height of the viewport
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 */
	public static final Matrix4d infinitePerspectiveLH(double fovy, double aspect, double zNear) {
		final double range = Trigonometric.tan(fovy / (2)) * zNear;
		final double left = -range * aspect;
		final double right = range * aspect;
		final double bottom = -range;
		final double top = range;

		Matrix4d Result = new Matrix4d(0);
		Result.set(0, 0, ((2) * zNear) / (right - left));
		Result.set(1, 1, ((2) * zNear) / (top - bottom));
		Result.set(2, 2, (1));
		Result.set(2, 3, (1));
		Result.set(3, 2, -(2) * zNear);
		return Result;
	}
	
	/**
     * Creates a matrix for a symmetric perspective-view frustum with far plane at infinite with <br> 
     * default handedness.
	 * 
	 * @param fovy  Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 */
	public static final Matrix4f infinitePerspective(float fovy, float aspect, float zNear) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return infinitePerspectiveLH(fovy, aspect, zNear);
		else
			return infinitePerspectiveRH(fovy, aspect, zNear);
	}
	
	/**
     * Creates a matrix for a symmetric perspective-view frustum with far plane at infinite with <br> 
     * default handedness.
	 * 
	 * @param fovy  Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 */
	public static final Matrix4d infinitePerspective(double fovy, double aspect, double zNear) {
		if(Setup.GLM_FORCE_LEFT_HANDED)
			return infinitePerspectiveLH(fovy, aspect, zNear);
		else
			return infinitePerspectiveRH(fovy, aspect, zNear);
	}
	
	/**
     * Creates a matrix for a symmetric perspective-view frustum with far plane at infinite for <br> 
     * graphics hardware that doesn't support depth clamping.
	 * 
	 * @param fovy  Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param ep Epsilon
	 */
	public static final Matrix4f tweakedInfinitePerspective(float fovy, float aspect, float zNear, float ep) {
		final float range = Trigonometric.tan(fovy / (2)) * zNear;
		final float left = -range * aspect;
		final float right = range * aspect;
		final float bottom = -range;
		final float top = range;

		Matrix4f Result = new Matrix4f((0));
		Result.set(0, 0,  ((2) * zNear) / (right - left));
		Result.set(1, 1,  ((2) * zNear) / (top - bottom));
		Result.set(2, 2,  ep - (1));
		Result.set(2, 3,  (-1));
		Result.set(3, 2,  (ep - (2)) * zNear);
		return Result;
	}
	
	/**
     * Creates a matrix for a symmetric perspective-view frustum with far plane at infinite for <br> 
     * graphics hardware that doesn't support depth clamping.
	 * 
	 * @param fovy  Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 */
	public static final Matrix4f tweakedInfinitePerspective(float fovy, float aspect, float zNear) {
		return tweakedInfinitePerspective(fovy, aspect, zNear, (float)ScalarConstants.epsilon());
	}
	
	/**
     * Creates a matrix for a symmetric perspective-view frustum with far plane at infinite for <br> 
     * graphics hardware that doesn't support depth clamping.
	 * 
	 * @param fovy  Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 * @param ep Epsilon
	 */
	public static final Matrix4d tweakedInfinitePerspective(double fovy, double aspect, double zNear, double ep) {
		final double range = Trigonometric.tan(fovy / (2)) * zNear;
		final double left = -range * aspect;
		final double right = range * aspect;
		final double bottom = -range;
		final double top = range;

		Matrix4d Result = new Matrix4d((0));
		Result.set(0, 0,  ((2) * zNear) / (right - left));
		Result.set(1, 1,  ((2) * zNear) / (top - bottom));
		Result.set(2, 2,  ep - (1));
		Result.set(2, 3,  (-1));
		Result.set(3, 2,  (ep - (2)) * zNear);
		return Result;
	}
	
	/**
     * Creates a matrix for a symmetric perspective-view frustum with far plane at infinite for <br> 
     * graphics hardware that doesn't support depth clamping.
	 * 
	 * @param fovy  Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	 * @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	 * @param zNear Specifies the distance from the viewer to the near clipping plane (always positive).
	 */
	public static final Matrix4d tweakedInfinitePerspective(double fovy, double aspect, double zNear) {
		return tweakedInfinitePerspective(fovy, aspect, zNear, ScalarConstants.epsilon());
	}
}
